import random
import time

# --- TARGET SYSTEM (VULNERABLE C CODE SIMULATION) ---
class VulnerableTarget:
    """Mock C-Library with a hidden Integer Overflow."""
    def process_header(self, length: int, content: str):
        # MOCK VULNERABILITY: 'length' is cast to short (max 32767) internally
        # If length > 32767, it wraps around (becomes negative or small positive)
        # while 'memcpy' uses the real length.
        
        # Simulating C 'short' cast overflow behavior
        internal_len = length
        if length > 32767:
             # Overflow logic: 32768 -> -32768 (Signed Short Overflow Simulation)
             # or simply wrapping logic for demo
             internal_len = (length + 32768) % 65536 - 32768
             
        # HEAP BUFFER: Allocated based on internal_len
        if internal_len < 0:
            return "ERROR: Negative Allocation Request"
        
        allocated_buffer = ["\0"] * internal_len
        
        # MEMCPY: Uses original 'length' (The Vulnerability)
        try:
            # Simulate memcpy(buffer, content, length)
            # If real length > allocated, we crash
            if length > len(allocated_buffer):
                return f"CRASH: Buffer Overflow! Wrote {length} bytes into {len(allocated_buffer)} buffer."
            else:
                return "SUCCESS: Header Processed."
        except Exception as e:
            return f"CRASH: {e}"

# --- MTI-EVO COMPONENTS ---

class DreamerFuzzer:
    """Generates High-Entropy Edge Cases."""
    def generate_vectors(self, num_vectors=10):
        vectors = []
        # Strategies: Boundary, Random, Format Strings
        strategies = ["Boundary", "RandomLarge", "Negative", "FormatString"]
        
        for _ in range(num_vectors):
            strat = random.choice(strategies)
            payload = "A" * 10
            length = 10
            
            if strat == "Boundary":
                 length = random.choice([32767, 32768, 65535, 65536])
            elif strat == "RandomLarge":
                 length = random.randint(10000, 100000)
            elif strat == "Negative":
                 length = random.randint(-100, -1)
            elif strat == "FormatString":
                 payload = "%x%x%x%x"
                 length = len(payload)
                 
            vectors.append({"strategy": strat, "length": length, "payload": payload})
        return vectors

class CriticFilter:
    """Filters for Technical Plausibility."""
    def assess(self, vector):
        # Discard vectors that are syntax errors or irrelevant
        # We value 'Boundary' conditions for Memory Safety
        if vector["strategy"] == "Boundary":
            return True, "High Probability (Edge Case)"
        if vector["strategy"] == "RandomLarge":
            return True, "Medium Probability (Stress Test)"
        return False, "Low Relevance"

class BridgeVerifier:
    """Simulates Z3 Symbolic Execution."""
    def verify(self, vector, target):
        print(f"   [Symbolic Exec] Solving constraints for len={vector['length']}...")
        result = target.process_header(vector['length'], vector['payload'])
        
        if "CRASH" in result:
            return True, result
        return False, result

# --- ORCHESTRATOR ---
if __name__ == "__main__":
    print("--- Project 3: Vulnerability Synthesizer (Mock) ---")
    target = VulnerableTarget()
    dreamer = DreamerFuzzer()
    critic = CriticFilter()
    bridge = BridgeVerifier()
    
    # 1. Dream Phase
    print("1. Dreaming Attack Vectors...")
    raw_vectors = dreamer.generate_vectors(num_vectors=20)
    
    # 2. Critique Phase
    print("2. Critiquing & Filtering...")
    candidates = []
    for v in raw_vectors:
        valid, reason = critic.assess(v)
        if valid:
            candidates.append(v)
            
    print(f"   -> Filtered {len(raw_vectors)} down to {len(candidates)} high-value candidates.")
    
    # 3. Verification Phase
    print("3. Symbolic Verification (Bridge)...")
    found_vuln = False
    for v in candidates:
        is_vuln, outcome = bridge.verify(v, target)
        if is_vuln:
            print(f"ðŸš¨ VULNERABILITY CONFIRMED!")
            print(f"   Input: Length={v['length']}")
            print(f"   Result: {outcome}") 
            print(f"   Root Cause: Integer Overflow (Active > Allocated)")
            found_vuln = True
            break # Stop after finding one, representative of 'Responsible Disclosure' workflow
            
    if not found_vuln:
        print("No vulnerabilities found in this pass. System appears robust.")
